#structures, #classes, #enumerations, #unions

___
# Introduction
___

C++ built-in types are deliberately low-level. But C++ acquires _abstraction mechanisms_ that allow the programmer to built _user-defined types_.

User-defined types are referred to as _classes and enumerations_.

User-defined types vs built-in types:
- Easier to use
- Less error-prone
- Just as efficient, or even more

---
# Structures
---

The `new` operator allocates memory from an area called the _free store_ (also known as _dynamic memory_ and _heap_).

Objects allocated on the free store are independent of the scope from which they are created and "live" until they are destroyed using the `delete` operator.

Use `.`(dot) to access struct members through a name (and a reference). And `->` to access struct members through a pointer.

---
# Classes
---

A _class_ is a language mechanism that distinguishes between the interface to a type (to be used by all) and its implementation (which has access to the otherwise inaccessible data).

(The _interface_ is a way to describe the behavior of a class without committing to the implementation of the class.)

The interface of a class is define by it `public` and `private` members. Conventionally, the private parts come after the public ones.

The `private` parts are accessible only through that interface.

_Constructor_ is a function that guarantees to initialize objects of its class. Thus, using a constructor eliminates the problem of uninitialized variables for a class.

The book's example uses a _member initializer list_. I copied just the constructor of the class named Vector:

`Vector(int s) :elem{new double[s]}, sz{s} {}`

In the book's example there is a subscript function, called `operator[]` that return a reference to the appropriate element. And it is noted that a `double&` allows both reading and writing.

A `struct` is simply a `class` with members public by default.

---
# Enumerations
---

_Enumerations_ represent small sets of integer values. Their cons are:
- They make code more readable
- Less error-prone


