# 1.1 Introduction

- Notation of C++
- C++'s model of memory
- Basic mechanisms for organizing code into a program

# 1.2 Programs

C++ is a _compiled_ language: Many source files are being compiled and object files are created. Then these object files are linked with a _linker_ and and executable program is created.

These executable programs are software/hardware dependent, so they aren't portable, but the source files are.

The ISO C++ defines:
- Core _language features_, such built-in types (e.g. char, int) and loops (e.g. for, while)
- _Standard-library components_ such as containers (e.g. vector, map) and I/O operations (e.g. << and getline())

C++ is _statically typed_ language, the type of every entity must be known to the compiler beforehand.

C++ std library components are written mainly in C++ with minor use of machine code (e.g. for thread context switching, check [[i.Appendix#Thread Context Switch vs Process Context Switch]])

## 1.2.1 Hello, World!

- Every program must have exactly one main()
- If no value is returned by main(), then success
- Nonzero value indicates failure

_String literal_ is a sequence of characters surrounded by double quotes.

# 1.3 Functions

Function declaration:
- name of function
- type of returned value
- number and types of args

If function declaration isn't also definition, then the argument names are ignored.

More and shorter functions -> less errors

If there are 2 or more functions with the same name, then the compiler will choose the most suitable to invoke in each call.

_Function overloading_: multiple functions with the same name.

Functions with common name should implement the same semantics.

# 1.4 Types, Variables, and Arithmetic

| | |
| --- | --- |
|Type|Defines a set of possible values and operations|
|Declaration|A statement that introduces an entity into the program and specifies its type|
|Object|Some memory that holds a value of some type|
|Variable|A named object|

## 1.4.1 Arithmetic

Use single quote as a digit separator to make long literals more readable.

## 1.4.2 Initialization

Initialization with `{}` saves you from conversions that loose information.

# 1.5 Scope and Lifetime

A declaration introduces its name into a scope:
- Local: In a function or lambda
- Class: Member named if defined outside of any function, lambda, or enum class
- Namespace: If it is defined inside a namespace outside of all of the above

Global name when defined outside of all of the above

# 1.6 Constants

2 notions of immutability:

| | |
| --- | --- |
| const | _"I promise not to change"_ |
| constexp | _"To be evaluated at compile time"_ |

Functions evaluated by compiler must be defined as `constexp` or `consteval`.

# 1.7 Pointers, Arrays, and References

| | | | 
| :---: | :---: | :---: | :---: |
|Operator|In declaration:|In an expression(rhs):|
|`[]`|_array of_||
|`*`|_pointer to_|_contents of_|
|`&`|_reference to_|_address of_|

A reference is like a pointer, BUT:
- You don't need to use `*` to access the value
- It can't show to different object after initialization

__Tip__: Using `const <type> <varName> &`, you:
1. Don't risk value modification
2. Get rid of cost of copy

## 1.7.1 The Null Pointer

1. Represents notion of _"no-object is available" _
2. Don't have an object to point to

One `nullptr` is shared by all pointer types.

__Tip__: Check if a pointer argument actually points to something.

In older code `0` or `NULL` are used instead of `nullptr`.

# 1.8 Tests

You can use switch, if, and for statements.

The _switch-statement_ tests a value against a set of constants.

# 1.9 Mapping and Hardware

_"A C++ implementation sees a machine's memory as a sequence of memory locations into which it can place (typed) objects and address them using pointers."_